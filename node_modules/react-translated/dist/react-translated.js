'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var propTypes = require('prop-types');

//      

var TranslatedShape = propTypes.shape({
  getLanguage: propTypes.func.isRequired,
  getTranslation: propTypes.func.isRequired,
  subscribe: propTypes.func.isRequired
});

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

//      

var Provider = function (_React$Component) {
  inherits(Provider, _React$Component);

  function Provider() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Provider);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Provider.__proto__ || Object.getPrototypeOf(Provider)).call.apply(_ref, [this].concat(args))), _this), _this.translated = {
      getIsDebugging: function getIsDebugging() {
        return !!_this.props.isDebugging;
      },
      getLanguage: function getLanguage() {
        return _this.props.language;
      },
      getTranslation: function getTranslation() {
        return _this.props.translation;
      },
      subscribe: function subscribe(callback) {
        return _this.subscribe(callback);
      }
    }, _this.listeners = [], _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Provider, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        translated: this.translated
      };
    }
  }, {
    key: 'subscribe',
    value: function subscribe(callback) {
      var _this2 = this;

      this.listeners.push(callback);
      return function () {
        var index = _this2.listeners.indexOf(callback);
        if (index > -1) {
          _this2.listeners.splice(index, 1);
        }
      };
    }
  }, {
    key: 'notify',
    value: function notify() {
      if (this.listeners) {
        this.listeners.forEach(function (listener) {
          return listener();
        });
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.language !== nextProps.language || this.props.translation !== nextProps.translation) {
        this.notify();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return this.props.children;
    }
  }]);
  return Provider;
}(React.Component);

Provider.childContextTypes = {
  translated: TranslatedShape.isRequired
};

//      

var createSubscribe = function createSubscribe(_ref) {
  var _class, _temp;

  var Component$$1 = _ref.Component;
  return _temp = _class = function (_React$PureComponent) {
    inherits(Subscribe, _React$PureComponent);

    function Subscribe() {
      classCallCheck(this, Subscribe);
      return possibleConstructorReturn(this, (Subscribe.__proto__ || Object.getPrototypeOf(Subscribe)).apply(this, arguments));
    }

    createClass(Subscribe, [{
      key: 'render',
      value: function render() {
        return React.createElement(Component$$1, _extends({}, this.props, { translated: this.context.translated }));
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var _this2 = this;

        this.unsubscribe = this.context.translated.subscribe(function () {
          return _this2.forceUpdate();
        });
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.unsubscribe();
      }
    }]);
    return Subscribe;
  }(React.PureComponent), _class.contextTypes = {
    translated: TranslatedShape.isRequired
  }, _temp;
};

//      


var createTranslate = function createTranslate(_ref) {
  var renderer = _ref.renderer,
      renderTranslated = _ref.renderTranslated;

  var Translate = function (_React$Component) {
    inherits(Translate, _React$Component);

    function Translate() {
      classCallCheck(this, Translate);
      return possibleConstructorReturn(this, (Translate.__proto__ || Object.getPrototypeOf(Translate)).apply(this, arguments));
    }

    createClass(Translate, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            data = _props.data,
            text = _props.text,
            renderMap = _props.renderMap,
            onPressLink = _props.onPressLink,
            translated = _props.translated;

        return renderTranslated({
          text: text,
          data: data,
          renderMap: renderMap,
          translated: translated,
          onPressLink: onPressLink
        });
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        if (renderer === 'native' && !this.context.isInAParentText) {
          throw new Error('Cannot place translated text outside a text node');
        }
      }
    }]);
    return Translate;
  }(React.Component);

  Translate.contextTypes = {
    isInAParentText: renderer === 'native' ? propTypes.bool : propTypes.any
  };

  return createSubscribe({ Component: Translate });
};

var _extends$1 = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



































var toConsumableArray$1 = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

//      


var parser = function parser(_ref) {
  var renderers = _ref.renderers;

  var normalizedRenderers = normalizeRenderers({ renderers: renderers });
  return function (_ref2) {
    var data = _ref2.data,
        text = _ref2.text;

    var contexts = parse({ renderers: normalizedRenderers, text: text });
    return render({ contexts: contexts, data: data, text: text });
  };
};

///////////
// PARSE //
///////////


var parse = function parse(_ref3) {
  var renderers = _ref3.renderers,
      text = _ref3.text;


  var regExpParts = renderers.map(function (renderer) {
    return '(' + renderer.regExpPart + ')';
  });
  var regExp = new RegExp(regExpParts.join('|'), 'gm');

  var contexts = [];
  var lastIndex = 0;
  var regExpResult = void 0;

  while (regExpResult = regExp.exec(text)) {

    var beforeChunk = text.substring(lastIndex, regExpResult.index);
    lastIndex = regExp.lastIndex;

    if (beforeChunk) {
      contexts.push(beforeChunk);
    }

    renderers.some(function (renderer) {
      if (renderer.groupIndexes.some(function (gI) {
        return regExpResult[gI] != null;
      })) {
        var matches = regExpResult.filter(function (_, index) {
          return renderer.groupIndexes.includes(index);
        }).slice(1);
        contexts.push({ matches: matches, renderer: renderer });
        return true;
      }
    });
  }

  var afterChunk = text.slice(lastIndex);
  if (afterChunk) {
    contexts.push(afterChunk);
  }

  return contexts;
};

////////////
// RENDER //
////////////


var render = function render(_ref4) {
  var contexts = _ref4.contexts,
      data = _ref4.data,
      text = _ref4.text;


  var tree = [];
  var currentIndex = 0;
  var safety = 1000;

  var _loop = function _loop() {

    if (!safety--) {
      console.error('Breaking early to avoid potential infinite loop');
      return 'break';
    }

    // If every item up to (and including) the current one is a string,
    // move the items from the contexts to the tree.
    var isPlainString = contexts.slice(0, currentIndex + 1).every(function (item) {
      return typeof item === 'string';
    });
    if (isPlainString) {
      var removedItems = contexts.splice(0, currentIndex + 1);
      tree.push.apply(tree, toConsumableArray$1(removedItems));
      currentIndex = 0;
      return 'continue';
    }

    var currentContext = contexts[currentIndex];
    if (!currentContext || !currentContext.renderer || !currentContext.renderer.render) {
      console.error('No renderer found for the matching context in %o at %o', contexts, currentIndex);
      return 'break';
    }

    // If there is no context closer for the current context, strip it out.
    var hasContextCloser = contexts.some(function (context) {
      return context !== currentContext && context && context.renderer && context.renderer.render === currentContext.renderer.render;
    });
    if (!hasContextCloser) {
      contexts.splice(currentIndex, 1);
      currentIndex = 0;
      return 'continue';
    }

    var nextContextIndex = contexts.findIndex(function (context, index) {
      return index > currentIndex && context && context.renderer && context.renderer.render;
    });
    var nextContext = contexts[nextContextIndex];
    if (!nextContext) {
      throw new Error('Unable to render text: "' + text + '"');
    }

    // If the next renderer is different, there is a nested renderer,
    // so move on to the next renderer's index.
    if (nextContext.renderer.render !== currentContext.renderer.render) {
      currentIndex = nextContextIndex;
      return 'continue';
    }

    // Otherwise, there is no nested renderer,
    // so grab the children and matches to render the element.
    var element = nextContext.renderer.render({
      key: tree.length + ':' + currentIndex + ':' + nextContextIndex,
      children: contexts.slice(currentIndex + 1, nextContextIndex),
      data: data,
      startMatches: currentContext.matches,
      endMatches: nextContext.matches
    });

    // If this is a nested renderer, splice the element's context down to the element.
    // Otherwise, remove the element's context and add the element to the tree.
    if (currentIndex !== 0) {
      contexts.splice(currentIndex, nextContextIndex - currentIndex + 1, element);
    } else {
      contexts.splice(0, nextContextIndex + 1);
      tree.push(element);
    }

    // Start again from the start of the context
    currentIndex = 0;
  };

  _loop2: while (contexts.length) {
    var _ret = _loop();

    switch (_ret) {
      case 'break':
        break _loop2;

      case 'continue':
        continue;}
  }

  return tree;
};

///////////
// UTILS //
///////////


var normalizeRenderers = function normalizeRenderers(_ref5) {
  var renderers = _ref5.renderers;

  return renderers.reduce(function (accumulator, renderer, index) {

    var previousMatchIndexes = accumulator[accumulator.length - 1];
    var previousLastGroupIndex = previousMatchIndexes ? previousMatchIndexes.groupIndexes[previousMatchIndexes.groupIndexes.length - 1] : 0;

    var match = renderer.match;

    if (typeof match === 'string') {
      var groupsCount = getGroupsCount({ regExp: new RegExp(match) }) + 1;
      accumulator.push(_extends$1({}, renderer, {
        regExpPart: match,
        groupIndexes: Array.from(new Array(groupsCount)).map(function (_, index) {
          return index + previousLastGroupIndex + 1;
        })
      }));
    } else {
      var startGroupsCount = getGroupsCount({ regExp: new RegExp(match.start) }) + 1;
      accumulator.push(_extends$1({}, renderer, {
        regExpPart: match.start,
        groupIndexes: Array.from(new Array(startGroupsCount)).map(function (_, index) {
          return index + previousLastGroupIndex + 1;
        })
      }));
      var endGroupsCount = getGroupsCount({ regExp: new RegExp(match.end) }) + 1;
      accumulator.push(_extends$1({}, renderer, {
        regExpPart: match.end,
        groupIndexes: Array.from(new Array(endGroupsCount)).map(function (_, index) {
          return index + previousLastGroupIndex + 1 + startGroupsCount;
        })
      }));
    }

    return accumulator;
  }, []);
};

var getGroupsCount = function getGroupsCount(_ref6) {
  var regExp = _ref6.regExp;

  var newRegExp = new RegExp(regExp.toString() + '|');
  return newRegExp.exec('').length - 1;
};

//      

///////////
// MATCH //
///////////


var getForBoldText = function getForBoldText(_ref) {
  var Component$$1 = _ref.Component;
  return {
    match: '\\*',
    render: function render(_ref2) {
      var children = _ref2.children;

      return React.createElement(
        Component$$1.BoldText,
        null,
        children
      );
    }
  };
};

var getForLinkText = function getForLinkText(_ref3) {
  var Component$$1 = _ref3.Component;
  return {
    match: { start: '\\[', end: '\\]\\((.*?)\\)' },
    render: function render(_ref4) {
      var children = _ref4.children,
          data = _ref4.data,
          endMatches = _ref4.endMatches;

      var url = endMatches[0] || '';
      var onPress = data.onPressLink;
      return React.createElement(
        Component$$1.Link,
        { onPress: onPress, url: url },
        children
      );
    }
  };
};

var getForCustomComponents = function getForCustomComponents() {
  return {
    match: { start: '<', end: '>' },
    render: function render(_ref5) {
      var children = _ref5.children,
          data = _ref5.data;

      var componentName = typeof children[0] === 'string' ? children[0] : '';
      var render = data.renderMap && data.renderMap['render' + componentName];
      if (!render) {
        throw new Error('Render method "render' + componentName + '" not passed');
      }
      return render(data.templateData);
    }
  };
};

///////////////
// VARIABLES //
///////////////

var variablesRenderer = {
  match: { start: '\\{', end: '\\}' },
  render: function render(_ref6) {
    var data = _ref6.data,
        children = _ref6.children;

    return data[children] || '';
  }
};

var renderVariables = parser({
  renderers: [variablesRenderer]
});

var interpolateData = function interpolateData(_ref7) {
  var data = _ref7.data,
      text = _ref7.text;
  return renderVariables({ data: data, text: text }).join('');
};

//      


var getTranslatedText = function getTranslatedText(_ref) {
  var data = _ref.data,
      text = _ref.text,
      translated = _ref.translated;

  var translation = translated.getTranslation();
  var language = translated.getLanguage();
  if (!translation || !language) {
    throw new Error('No translation data provided. Make sure your <Provider> is set up correctly.');
  }

  // Grab the template from the translation data
  // and default to the text if none is found.
  var template = translation[text] ? translation[text][language] : undefined;

  // If it's a function, it is a dynamic template, so invoke it with the data
  // and return the final template
  var translatedText = typeof template === 'function' ? template(data || {}) : template;
  return typeof translatedText === 'string' ? translatedText : '';
};

//      


var createRenderer = function createRenderer(_ref) {
  var Component$$1 = _ref.Component;

  var render = parser({
    renderers: [getForBoldText({ Component: Component$$1 }), getForLinkText({ Component: Component$$1 }), getForCustomComponents()]
  });
  return function (_ref2) {
    var text = _ref2.text,
        data = _ref2.data,
        renderMap = _ref2.renderMap,
        translated = _ref2.translated,
        onPressLink = _ref2.onPressLink;

    var translatedText = getTranslatedText({ data: data, text: text, translated: translated });
    var renderedText = interpolateData({
      data: data,
      text: translatedText || text
    });

    var chunks = render({
      data: { templateData: data, onPressLink: onPressLink, renderMap: renderMap },
      text: renderedText
    }).map(function (chunk, index) {
      return typeof chunk === 'string' ? chunk : React.cloneElement(chunk, { key: index });
    });

    var isDebugging = translated.getIsDebugging();
    var isMissing = !translatedText;
    if (!isDebugging || !isMissing) {
      return chunks;
    }
    var style = { backgroundColor: 'red' };
    return React.createElement(
      Component$$1.Text,
      { style: style },
      chunks
    );
  };
};

//      

var styleSheet = {
  link: { fontWeight: 'bold', textDecoration: 'underline' }
};

var Link = function Link(_ref) {
  var onPress = _ref.onPress,
      children = _ref.children,
      url = _ref.url;
  return React.createElement(
    'a',
    {
      onClick: onPress ? function () {
        return onPress && onPress({ url: url });
      } : undefined,
      href: url,
      style: styleSheet.link
    },
    children
  );
};

var renderTranslated = createRenderer({
  Component: {
    BoldText: 'b',
    Text: 'span',
    Link: Link
  }
});

var Translate = createTranslate({
  renderer: 'dom',
  renderTranslated: renderTranslated
});

//      


var Translator = function (_React$Component) {
  inherits(Translator, _React$Component);

  function Translator() {
    classCallCheck(this, Translator);
    return possibleConstructorReturn(this, (Translator.__proto__ || Object.getPrototypeOf(Translator)).apply(this, arguments));
  }

  createClass(Translator, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var children = this.props.children;

      return children({
        translate: function translate(_ref) {
          var data = _ref.data,
              text = _ref.text;
          return _this2.translate({ data: data, text: text });
        }
      });
    }
  }, {
    key: 'translate',
    value: function translate(_ref2) {
      var data = _ref2.data,
          text = _ref2.text;
      var translated = this.props.translated;

      var translatedText = getTranslatedText({
        data: data,
        text: text,
        translated: translated
      });
      return interpolateData({ data: data, text: translatedText });
    }
  }]);
  return Translator;
}(React.Component);

var Translator$1 = createSubscribe({ Component: Translator });

//      

var index = {
  Provider: Provider,
  Translate: Translate,
  Translator: Translator$1
};

exports['default'] = index;
exports.Provider = Provider;
exports.Translate = Translate;
exports.Translator = Translator$1;
