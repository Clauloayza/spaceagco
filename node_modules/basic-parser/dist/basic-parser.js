var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



































var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

//      


var parser = function parser(_ref) {
  var renderers = _ref.renderers;

  var normalizedRenderers = normalizeRenderers({ renderers: renderers });
  return function (_ref2) {
    var data = _ref2.data,
        text = _ref2.text;

    var contexts = parse({ renderers: normalizedRenderers, text: text });
    return render({ contexts: contexts, data: data, text: text });
  };
};

///////////
// PARSE //
///////////


var parse = function parse(_ref3) {
  var renderers = _ref3.renderers,
      text = _ref3.text;


  var regExpParts = renderers.map(function (renderer) {
    return '(' + renderer.regExpPart + ')';
  });
  var regExp = new RegExp(regExpParts.join('|'), 'gm');

  var contexts = [];
  var lastIndex = 0;
  var regExpResult = void 0;

  while (regExpResult = regExp.exec(text)) {

    var beforeChunk = text.substring(lastIndex, regExpResult.index);
    lastIndex = regExp.lastIndex;

    if (beforeChunk) {
      contexts.push(beforeChunk);
    }

    renderers.some(function (renderer) {
      if (renderer.groupIndexes.some(function (gI) {
        return regExpResult[gI] != null;
      })) {
        var matches = regExpResult.filter(function (_, index) {
          return renderer.groupIndexes.includes(index);
        }).slice(1);
        contexts.push({ matches: matches, renderer: renderer });
        return true;
      }
    });
  }

  var afterChunk = text.slice(lastIndex);
  if (afterChunk) {
    contexts.push(afterChunk);
  }

  return contexts;
};

////////////
// RENDER //
////////////


var render = function render(_ref4) {
  var contexts = _ref4.contexts,
      data = _ref4.data,
      text = _ref4.text;


  var tree = [];
  var currentIndex = 0;
  var safety = 1000;

  var _loop = function _loop() {

    if (!safety--) {
      console.error('Breaking early to avoid potential infinite loop');
      return 'break';
    }

    // If every item up to (and including) the current one is a string,
    // move the items from the contexts to the tree.
    var isPlainString = contexts.slice(0, currentIndex + 1).every(function (item) {
      return typeof item === 'string';
    });
    if (isPlainString) {
      var removedItems = contexts.splice(0, currentIndex + 1);
      tree.push.apply(tree, toConsumableArray(removedItems));
      currentIndex = 0;
      return 'continue';
    }

    var currentContext = contexts[currentIndex];
    if (!currentContext || !currentContext.renderer || !currentContext.renderer.render) {
      console.error('No renderer found for the matching context in %o at %o', contexts, currentIndex);
      return 'break';
    }

    // If there is no context closer for the current context, strip it out.
    var hasContextCloser = contexts.some(function (context) {
      return context !== currentContext && context && context.renderer && context.renderer.render === currentContext.renderer.render;
    });
    if (!hasContextCloser) {
      contexts.splice(currentIndex, 1);
      currentIndex = 0;
      return 'continue';
    }

    var nextContextIndex = contexts.findIndex(function (context, index) {
      return index > currentIndex && context && context.renderer && context.renderer.render;
    });
    var nextContext = contexts[nextContextIndex];
    if (!nextContext) {
      throw new Error('Unable to render text: "' + text + '"');
    }

    // If the next renderer is different, there is a nested renderer,
    // so move on to the next renderer's index.
    if (nextContext.renderer.render !== currentContext.renderer.render) {
      currentIndex = nextContextIndex;
      return 'continue';
    }

    // Otherwise, there is no nested renderer,
    // so grab the children and matches to render the element.
    var element = nextContext.renderer.render({
      key: tree.length + ':' + currentIndex + ':' + nextContextIndex,
      children: contexts.slice(currentIndex + 1, nextContextIndex),
      data: data,
      startMatches: currentContext.matches,
      endMatches: nextContext.matches
    });

    // If this is a nested renderer, splice the element's context down to the element.
    // Otherwise, remove the element's context and add the element to the tree.
    if (currentIndex !== 0) {
      contexts.splice(currentIndex, nextContextIndex - currentIndex + 1, element);
    } else {
      contexts.splice(0, nextContextIndex + 1);
      tree.push(element);
    }

    // Start again from the start of the context
    currentIndex = 0;
  };

  _loop2: while (contexts.length) {
    var _ret = _loop();

    switch (_ret) {
      case 'break':
        break _loop2;

      case 'continue':
        continue;}
  }

  return tree;
};

///////////
// UTILS //
///////////


var normalizeRenderers = function normalizeRenderers(_ref5) {
  var renderers = _ref5.renderers;

  return renderers.reduce(function (accumulator, renderer, index) {

    var previousMatchIndexes = accumulator[accumulator.length - 1];
    var previousLastGroupIndex = previousMatchIndexes ? previousMatchIndexes.groupIndexes[previousMatchIndexes.groupIndexes.length - 1] : 0;

    var match = renderer.match;

    if (typeof match === 'string') {
      var groupsCount = getGroupsCount({ regExp: new RegExp(match) }) + 1;
      accumulator.push(_extends({}, renderer, {
        regExpPart: match,
        groupIndexes: Array.from(new Array(groupsCount)).map(function (_, index) {
          return index + previousLastGroupIndex + 1;
        })
      }));
    } else {
      var startGroupsCount = getGroupsCount({ regExp: new RegExp(match.start) }) + 1;
      accumulator.push(_extends({}, renderer, {
        regExpPart: match.start,
        groupIndexes: Array.from(new Array(startGroupsCount)).map(function (_, index) {
          return index + previousLastGroupIndex + 1;
        })
      }));
      var endGroupsCount = getGroupsCount({ regExp: new RegExp(match.end) }) + 1;
      accumulator.push(_extends({}, renderer, {
        regExpPart: match.end,
        groupIndexes: Array.from(new Array(endGroupsCount)).map(function (_, index) {
          return index + previousLastGroupIndex + 1 + startGroupsCount;
        })
      }));
    }

    return accumulator;
  }, []);
};

var getGroupsCount = function getGroupsCount(_ref6) {
  var regExp = _ref6.regExp;

  var newRegExp = new RegExp(regExp.toString() + '|');
  return newRegExp.exec('').length - 1;
};

export default parser;
